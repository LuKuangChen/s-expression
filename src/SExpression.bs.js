// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Core__List from "@rescript/core/src/Core__List.bs.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function toString(x) {
  var $$escape = function (s) {
    var s$1 = Js_string.replaceByRe(/\\n/g, "\n", s);
    var s$2 = Js_string.replaceByRe(/\\t/g, "\t", s$1);
    var s$3 = Js_string.replaceByRe(/\\r/g, "\r", s$2);
    var s$4 = Js_string.replaceByRe(/\\\\/g, "\\", s$3);
    return Js_string.replaceByRe(/\\\"/g, "\"", s$4);
  };
  if (x.TAG === "Str") {
    return "\"" + $$escape(x._0) + "\"";
  } else {
    return x._0;
  }
}

var Atom = {
  toString: toString
};

function toString$1(t) {
  if (t === "Round") {
    return "round";
  } else {
    return "square";
  }
}

function toWrapper(t) {
  if (t === "Round") {
    return [
            "(",
            ")"
          ];
  } else {
    return [
            "[",
            "]"
          ];
  }
}

var Bracket = {
  toString: toString$1,
  toWrapper: toWrapper
};

function toString$2(param) {
  return (param.ln + 1 | 0).toString() + ":" + param.ch.toString();
}

var SourcePoint = {
  toString: toString$2
};

function toString$3(param) {
  return toString$2(param.begin) + "-" + toString$2(param.end);
}

var SourceLocation = {
  toString: toString$3
};

function toString$4(t) {
  if (t === "List") {
    return "list";
  } else {
    return "vector";
  }
}

var SequenceKind = {
  toString: toString$4
};

function toString$5(err) {
  if (typeof err !== "object") {
    if (err === "WantListFoundEOF") {
      return "reached the end of the file while processing a list.";
    } else {
      return "reached the end of the file while processing a string.";
    }
  }
  switch (err.TAG) {
    case "WantEscapableCharFound" :
        return "found an unexpected escape sequence (\\" + err._0 + ").";
    case "MismatchedBracket" :
        return "found a closing " + toString$1(err._1) + " bracket while processing a list started with a " + toString$1(err._0) + " bracket.";
    case "ExtraClosingBracket" :
        return "found an extra closing " + toString$1(err._0) + " bracket at " + toString$2(err._1) + ".";
    
  }
}

var $$Error = {
  toString: toString$5
};

var SExpressionError = /* @__PURE__ */Caml_exceptions.create("SExpression.SExpressionError");

function toString$6(e) {
  var x = e.it;
  if (x.TAG === "Atom") {
    return toString(x._0);
  }
  var sequenceKind;
  sequenceKind = x.sequenceKind === "List" ? "" : "#";
  var match = toWrapper(x.bracket);
  return sequenceKind + match[0] + Caml_splice_call.spliceObjApply(" ", "concat", [Core__List.toArray(Core__List.map(x.content, toString$6))]) + match[1];
}

function annotate(it, begin, end) {
  return {
          it: it,
          ann: {
            begin: begin,
            end: end
          }
        };
}

function stringAsSource(s) {
  return {
          srcloc: {
            ln: 0,
            ch: 0
          },
          i: 0,
          content: s
        };
}

function advance(srcloc, $$char) {
  var ln = srcloc.ln;
  if ($$char === "\n") {
    return {
            ln: ln + 1 | 0,
            ch: 0
          };
  } else {
    return {
            ln: ln,
            ch: srcloc.ch + 1 | 0
          };
  }
}

function caseSource(source) {
  var content = source.content;
  var i = source.i;
  if (i >= content.length) {
    return ;
  }
  var ch = content[i];
  var srcloc = advance(source.srcloc, ch);
  return [
          ch,
          {
            srcloc: srcloc,
            i: i + 1 | 0,
            content: content
          }
        ];
}

function raiseError(x) {
  throw {
        RE_EXN_ID: SExpressionError,
        _1: x,
        Error: new Error()
      };
}

function parseSymbol(start, firstCh, src) {
  var _cs = {
    hd: firstCh,
    tl: /* [] */0
  };
  var _src = src;
  while(true) {
    var src$1 = _src;
    var cs = _cs;
    var end = (function(cs,src$1){
    return function end() {
      var e = {
        TAG: "Atom",
        _0: {
          TAG: "Sym",
          _0: Caml_splice_call.spliceObjApply("", "concat", [Core__List.toArray(Core__List.reverse(cs))])
        }
      };
      return [
              annotate(e, start, src$1.srcloc),
              src$1
            ];
    }
    }(cs,src$1));
    var match = caseSource(src$1);
    if (match === undefined) {
      return end();
    }
    var chr = match[0];
    switch (chr) {
      case "(" :
      case ")" :
      case "[" :
      case "\"" :
      case "]" :
          return end();
      default:
        if (/\s+/ig.test(chr)) {
          return end();
        }
        _src = match[1];
        _cs = {
          hd: chr,
          tl: cs
        };
        continue ;
    }
  };
}

function parseString(start, src) {
  var loop = function (_cs, _src) {
    while(true) {
      var src = _src;
      var cs = _cs;
      var match = caseSource(src);
      if (match !== undefined) {
        var chr = match[0];
        if (chr === "\"") {
          var src$1 = match[1];
          var e = {
            TAG: "Atom",
            _0: {
              TAG: "Str",
              _0: Caml_splice_call.spliceObjApply("", "concat", [Core__List.toArray(Core__List.reverse(cs))])
            }
          };
          return [
                  annotate(e, start, src$1.srcloc),
                  src$1
                ];
        }
        var src$2 = match[1];
        if (chr === "\\") {
          var match$1 = caseSource(src$2);
          if (match$1 !== undefined) {
            var src$3 = match$1[1];
            var chr$1 = match$1[0];
            switch (chr$1) {
              case "\"" :
                  return loop({
                              hd: "\"",
                              tl: cs
                            }, src$3);
              case "n" :
                  return loop({
                              hd: "\n",
                              tl: cs
                            }, src$3);
              case "r" :
                  return loop({
                              hd: "\r",
                              tl: cs
                            }, src$3);
              case "t" :
                  return loop({
                              hd: "\t",
                              tl: cs
                            }, src$3);
              default:
                if (chr$1 === "\\") {
                  return loop({
                              hd: "\\",
                              tl: cs
                            }, src$3);
                }
                throw {
                      RE_EXN_ID: SExpressionError,
                      _1: {
                        TAG: "WantEscapableCharFound",
                        _0: chr$1
                      },
                      Error: new Error()
                    };
            }
          } else {
            throw {
                  RE_EXN_ID: SExpressionError,
                  _1: "WantStringFoundEOF",
                  Error: new Error()
                };
          }
        }
        _src = src$2;
        _cs = {
          hd: chr,
          tl: cs
        };
        continue ;
      }
      throw {
            RE_EXN_ID: SExpressionError,
            _1: "WantStringFoundEOF",
            Error: new Error()
          };
    };
  };
  return loop(/* [] */0, src);
}

var EOF = /* @__PURE__ */Caml_exceptions.create("SExpression.SExpr.EOF");

function forwardToEOL(_src, then) {
  while(true) {
    var src = _src;
    var match = caseSource(src);
    if (match !== undefined) {
      if (match[0] === "\n") {
        return then(match[1]);
      }
      _src = match[1];
      continue ;
    }
    throw {
          RE_EXN_ID: EOF,
          Error: new Error()
        };
  };
}

var FoundRP = /* @__PURE__ */Caml_exceptions.create("SExpression.SExpr.FoundRP");

function parseOne(_src) {
  while(true) {
    var src = _src;
    var start = src.srcloc;
    var match = caseSource(src);
    if (match !== undefined) {
      var chr = match[0];
      switch (chr) {
        case "#" :
            var src$1 = match[1];
            var match$1 = caseSource(src$1);
            if (match$1 !== undefined) {
              switch (match$1[0]) {
                case "(" :
                    return startParseList("Vector", "Round", start, match$1[1]);
                case ";" :
                    var match$2 = parseOne(match$1[1]);
                    _src = match$2[1];
                    continue ;
                case "[" :
                    return startParseList("Vector", "Square", start, match$1[1]);
                default:
                  return parseSymbol(start, "#", src$1);
              }
            } else {
              throw {
                    RE_EXN_ID: EOF,
                    Error: new Error()
                  };
            }
        case "'" :
            var match$3 = parseOne(match[1]);
            var src$2 = match$3[1];
            return [
                    annotate({
                          TAG: "Sequence",
                          sequenceKind: "List",
                          bracket: "Round",
                          content: {
                            hd: annotate({
                                  TAG: "Atom",
                                  _0: {
                                    TAG: "Sym",
                                    _0: "quote"
                                  }
                                }, start, src$2.srcloc),
                            tl: {
                              hd: match$3[0],
                              tl: /* [] */0
                            }
                          }
                        }, start, src$2.srcloc),
                    src$2
                  ];
        case "(" :
            return startParseList("List", "Round", start, match[1]);
        case ")" :
            throw {
                  RE_EXN_ID: FoundRP,
                  _1: "Round",
                  _2: match[1],
                  Error: new Error()
                };
        case ";" :
            return forwardToEOL(match[1], parseOne);
        case "[" :
            return startParseList("List", "Square", start, match[1]);
        case "\"" :
            return parseString(start, match[1]);
        case "]" :
            throw {
                  RE_EXN_ID: FoundRP,
                  _1: "Square",
                  _2: match[1],
                  Error: new Error()
                };
        default:
          var src$3 = match[1];
          if (!/\s+/ig.test(chr)) {
            return parseSymbol(start, chr, src$3);
          }
          _src = src$3;
          continue ;
      }
    } else {
      throw {
            RE_EXN_ID: EOF,
            Error: new Error()
          };
    }
  };
}

function startParseList(sequenceKind, bracket1, start, src) {
  var _elms = /* [] */0;
  var _src = src;
  while(true) {
    var src$1 = _src;
    var elms = _elms;
    var val;
    try {
      val = parseOne(src$1);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === EOF) {
        throw {
              RE_EXN_ID: SExpressionError,
              _1: "WantListFoundEOF",
              Error: new Error()
            };
      }
      if (exn.RE_EXN_ID === FoundRP) {
        var src$2 = exn._2;
        var bracket2 = exn._1;
        if (bracket1 === bracket2) {
          var e_2 = Core__List.reverse(elms);
          var e = {
            TAG: "Sequence",
            sequenceKind: sequenceKind,
            bracket: bracket1,
            content: e_2
          };
          return [
                  annotate(e, start, src$2.srcloc),
                  src$2
                ];
        }
        throw {
              RE_EXN_ID: SExpressionError,
              _1: {
                TAG: "MismatchedBracket",
                _0: bracket1,
                _1: bracket2
              },
              Error: new Error()
            };
      }
      throw exn;
    }
    _src = val[1];
    _elms = {
      hd: val[0],
      tl: elms
    };
    continue ;
  };
}

function fromStringBeginning(src) {
  var val;
  try {
    val = parseOne(stringAsSource(src));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === EOF) {
      return ;
    }
    if (exn.RE_EXN_ID === FoundRP) {
      throw {
            RE_EXN_ID: SExpressionError,
            _1: {
              TAG: "ExtraClosingBracket",
              _0: exn._1,
              _1: exn._2.srcloc
            },
            Error: new Error()
          };
    }
    throw exn;
  }
  return [
          val[0],
          val[1].i
        ];
}

function fromString(src) {
  var _elms = /* [] */0;
  var _src = stringAsSource(src);
  while(true) {
    var src$1 = _src;
    var elms = _elms;
    var val;
    try {
      val = parseOne(src$1);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === EOF) {
        return Core__List.reverse(elms);
      }
      if (exn.RE_EXN_ID === FoundRP) {
        throw {
              RE_EXN_ID: SExpressionError,
              _1: {
                TAG: "ExtraClosingBracket",
                _0: exn._1,
                _1: exn._2.srcloc
              },
              Error: new Error()
            };
      }
      throw exn;
    }
    _src = val[1];
    _elms = {
      hd: val[0],
      tl: elms
    };
    continue ;
  };
}

var SExpr = {
  toString: toString$6,
  annotate: annotate,
  stringAsSource: stringAsSource,
  advance: advance,
  caseSource: caseSource,
  raiseError: raiseError,
  parseSymbol: parseSymbol,
  parseString: parseString,
  EOF: EOF,
  forwardToEOL: forwardToEOL,
  FoundRP: FoundRP,
  parseOne: parseOne,
  startParseList: startParseList,
  fromStringBeginning: fromStringBeginning,
  fromString: fromString
};

export {
  Atom ,
  Bracket ,
  SourcePoint ,
  SourceLocation ,
  SequenceKind ,
  $$Error ,
  SExpressionError ,
  SExpr ,
}
/* No side effect */
